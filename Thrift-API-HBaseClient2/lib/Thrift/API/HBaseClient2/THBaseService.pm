#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use Thrift::API::HBaseClient2::Types;

# HELPER FUNCTIONS AND STRUCTURES

package Thrift::API::HBaseClient2::THBaseService_exists_args;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_exists_args->mk_accessors( qw( table get ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{get} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{get}) {
      $self->{get} = $vals->{get};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_exists_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{get} = new Thrift::API::HBaseClient2::TGet();
        $xfer += $self->{get}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_exists_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{get}) {
    $xfer += $output->writeFieldBegin('get', TType::STRUCT, 2);
    $xfer += $self->{get}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_exists_result;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_exists_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_exists_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Thrift::API::HBaseClient2::TIOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_exists_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_get_args;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_get_args->mk_accessors( qw( table get ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{get} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{get}) {
      $self->{get} = $vals->{get};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_get_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{get} = new Thrift::API::HBaseClient2::TGet();
        $xfer += $self->{get}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_get_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{get}) {
    $xfer += $output->writeFieldBegin('get', TType::STRUCT, 2);
    $xfer += $self->{get}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_get_result;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_get_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_get_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Thrift::API::HBaseClient2::TResult();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Thrift::API::HBaseClient2::TIOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_get_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_getMultiple_args;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_getMultiple_args->mk_accessors( qw( table gets ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{gets} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{gets}) {
      $self->{gets} = $vals->{gets};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_getMultiple_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size42 = 0;
          $self->{gets} = [];
          my $_etype45 = 0;
          $xfer += $input->readListBegin(\$_etype45, \$_size42);
          for (my $_i46 = 0; $_i46 < $_size42; ++$_i46)
          {
            my $elem47 = undef;
            $elem47 = new Thrift::API::HBaseClient2::TGet();
            $xfer += $elem47->read($input);
            push(@{$self->{gets}},$elem47);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_getMultiple_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{gets}) {
    $xfer += $output->writeFieldBegin('gets', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{gets}}));
      {
        foreach my $iter48 (@{$self->{gets}}) 
        {
          $xfer += ${iter48}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_getMultiple_result;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_getMultiple_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_getMultiple_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size49 = 0;
          $self->{success} = [];
          my $_etype52 = 0;
          $xfer += $input->readListBegin(\$_etype52, \$_size49);
          for (my $_i53 = 0; $_i53 < $_size49; ++$_i53)
          {
            my $elem54 = undef;
            $elem54 = new Thrift::API::HBaseClient2::TResult();
            $xfer += $elem54->read($input);
            push(@{$self->{success}},$elem54);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Thrift::API::HBaseClient2::TIOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_getMultiple_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter55 (@{$self->{success}}) 
        {
          $xfer += ${iter55}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_put_args;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_put_args->mk_accessors( qw( table put ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{put} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{put}) {
      $self->{put} = $vals->{put};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_put_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{put} = new Thrift::API::HBaseClient2::TPut();
        $xfer += $self->{put}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_put_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{put}) {
    $xfer += $output->writeFieldBegin('put', TType::STRUCT, 2);
    $xfer += $self->{put}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_put_result;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_put_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_put_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Thrift::API::HBaseClient2::TIOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_put_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_checkAndPut_args;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_checkAndPut_args->mk_accessors( qw( table row family qualifier value put ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{row} = undef;
  $self->{family} = undef;
  $self->{qualifier} = undef;
  $self->{value} = undef;
  $self->{put} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{family}) {
      $self->{family} = $vals->{family};
    }
    if (defined $vals->{qualifier}) {
      $self->{qualifier} = $vals->{qualifier};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{put}) {
      $self->{put} = $vals->{put};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_checkAndPut_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{qualifier});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{put} = new Thrift::API::HBaseClient2::TPut();
        $xfer += $self->{put}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_checkAndPut_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{family}) {
    $xfer += $output->writeFieldBegin('family', TType::STRING, 3);
    $xfer += $output->writeString($self->{family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{qualifier}) {
    $xfer += $output->writeFieldBegin('qualifier', TType::STRING, 4);
    $xfer += $output->writeString($self->{qualifier});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 5);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{put}) {
    $xfer += $output->writeFieldBegin('put', TType::STRUCT, 6);
    $xfer += $self->{put}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_checkAndPut_result;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_checkAndPut_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_checkAndPut_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Thrift::API::HBaseClient2::TIOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_checkAndPut_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_putMultiple_args;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_putMultiple_args->mk_accessors( qw( table puts ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{puts} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{puts}) {
      $self->{puts} = $vals->{puts};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_putMultiple_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size56 = 0;
          $self->{puts} = [];
          my $_etype59 = 0;
          $xfer += $input->readListBegin(\$_etype59, \$_size56);
          for (my $_i60 = 0; $_i60 < $_size56; ++$_i60)
          {
            my $elem61 = undef;
            $elem61 = new Thrift::API::HBaseClient2::TPut();
            $xfer += $elem61->read($input);
            push(@{$self->{puts}},$elem61);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_putMultiple_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{puts}) {
    $xfer += $output->writeFieldBegin('puts', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{puts}}));
      {
        foreach my $iter62 (@{$self->{puts}}) 
        {
          $xfer += ${iter62}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_putMultiple_result;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_putMultiple_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_putMultiple_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Thrift::API::HBaseClient2::TIOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_putMultiple_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_deleteSingle_args;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_deleteSingle_args->mk_accessors( qw( table deleteSingle ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{deleteSingle} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{deleteSingle}) {
      $self->{deleteSingle} = $vals->{deleteSingle};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_deleteSingle_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{deleteSingle} = new Thrift::API::HBaseClient2::TDelete();
        $xfer += $self->{deleteSingle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_deleteSingle_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleteSingle}) {
    $xfer += $output->writeFieldBegin('deleteSingle', TType::STRUCT, 2);
    $xfer += $self->{deleteSingle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_deleteSingle_result;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_deleteSingle_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_deleteSingle_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Thrift::API::HBaseClient2::TIOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_deleteSingle_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_deleteMultiple_args;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_deleteMultiple_args->mk_accessors( qw( table deletes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{deletes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{deletes}) {
      $self->{deletes} = $vals->{deletes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_deleteMultiple_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size63 = 0;
          $self->{deletes} = [];
          my $_etype66 = 0;
          $xfer += $input->readListBegin(\$_etype66, \$_size63);
          for (my $_i67 = 0; $_i67 < $_size63; ++$_i67)
          {
            my $elem68 = undef;
            $elem68 = new Thrift::API::HBaseClient2::TDelete();
            $xfer += $elem68->read($input);
            push(@{$self->{deletes}},$elem68);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_deleteMultiple_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deletes}) {
    $xfer += $output->writeFieldBegin('deletes', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{deletes}}));
      {
        foreach my $iter69 (@{$self->{deletes}}) 
        {
          $xfer += ${iter69}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_deleteMultiple_result;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_deleteMultiple_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_deleteMultiple_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size70 = 0;
          $self->{success} = [];
          my $_etype73 = 0;
          $xfer += $input->readListBegin(\$_etype73, \$_size70);
          for (my $_i74 = 0; $_i74 < $_size70; ++$_i74)
          {
            my $elem75 = undef;
            $elem75 = new Thrift::API::HBaseClient2::TDelete();
            $xfer += $elem75->read($input);
            push(@{$self->{success}},$elem75);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Thrift::API::HBaseClient2::TIOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_deleteMultiple_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter76 (@{$self->{success}}) 
        {
          $xfer += ${iter76}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_checkAndDelete_args;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_checkAndDelete_args->mk_accessors( qw( table row family qualifier value deleteSingle ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{row} = undef;
  $self->{family} = undef;
  $self->{qualifier} = undef;
  $self->{value} = undef;
  $self->{deleteSingle} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{family}) {
      $self->{family} = $vals->{family};
    }
    if (defined $vals->{qualifier}) {
      $self->{qualifier} = $vals->{qualifier};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{deleteSingle}) {
      $self->{deleteSingle} = $vals->{deleteSingle};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_checkAndDelete_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{qualifier});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{deleteSingle} = new Thrift::API::HBaseClient2::TDelete();
        $xfer += $self->{deleteSingle}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_checkAndDelete_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{family}) {
    $xfer += $output->writeFieldBegin('family', TType::STRING, 3);
    $xfer += $output->writeString($self->{family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{qualifier}) {
    $xfer += $output->writeFieldBegin('qualifier', TType::STRING, 4);
    $xfer += $output->writeString($self->{qualifier});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 5);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleteSingle}) {
    $xfer += $output->writeFieldBegin('deleteSingle', TType::STRUCT, 6);
    $xfer += $self->{deleteSingle}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_checkAndDelete_result;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_checkAndDelete_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_checkAndDelete_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Thrift::API::HBaseClient2::TIOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_checkAndDelete_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_increment_args;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_increment_args->mk_accessors( qw( table increment ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{increment} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{increment}) {
      $self->{increment} = $vals->{increment};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_increment_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{increment} = new Thrift::API::HBaseClient2::TIncrement();
        $xfer += $self->{increment}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_increment_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{increment}) {
    $xfer += $output->writeFieldBegin('increment', TType::STRUCT, 2);
    $xfer += $self->{increment}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_increment_result;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_increment_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_increment_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Thrift::API::HBaseClient2::TResult();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Thrift::API::HBaseClient2::TIOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_increment_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_openScanner_args;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_openScanner_args->mk_accessors( qw( table scan ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{table} = undef;
  $self->{scan} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{table}) {
      $self->{table} = $vals->{table};
    }
    if (defined $vals->{scan}) {
      $self->{scan} = $vals->{scan};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_openScanner_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{table});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{scan} = new Thrift::API::HBaseClient2::TScan();
        $xfer += $self->{scan}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_openScanner_args');
  if (defined $self->{table}) {
    $xfer += $output->writeFieldBegin('table', TType::STRING, 1);
    $xfer += $output->writeString($self->{table});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan}) {
    $xfer += $output->writeFieldBegin('scan', TType::STRUCT, 2);
    $xfer += $self->{scan}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_openScanner_result;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_openScanner_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_openScanner_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Thrift::API::HBaseClient2::TIOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_openScanner_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_getScannerRows_args;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_getScannerRows_args->mk_accessors( qw( scannerId numRows ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scannerId} = undef;
  $self->{numRows} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scannerId}) {
      $self->{scannerId} = $vals->{scannerId};
    }
    if (defined $vals->{numRows}) {
      $self->{numRows} = $vals->{numRows};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_getScannerRows_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{scannerId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{numRows});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_getScannerRows_args');
  if (defined $self->{scannerId}) {
    $xfer += $output->writeFieldBegin('scannerId', TType::I32, 1);
    $xfer += $output->writeI32($self->{scannerId});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{numRows}) {
    $xfer += $output->writeFieldBegin('numRows', TType::I32, 2);
    $xfer += $output->writeI32($self->{numRows});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_getScannerRows_result;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_getScannerRows_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_getScannerRows_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size77 = 0;
          $self->{success} = [];
          my $_etype80 = 0;
          $xfer += $input->readListBegin(\$_etype80, \$_size77);
          for (my $_i81 = 0; $_i81 < $_size77; ++$_i81)
          {
            my $elem82 = undef;
            $elem82 = new Thrift::API::HBaseClient2::TResult();
            $xfer += $elem82->read($input);
            push(@{$self->{success}},$elem82);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Thrift::API::HBaseClient2::TIOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ia} = new Thrift::API::HBaseClient2::TIllegalArgument();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_getScannerRows_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter83 (@{$self->{success}}) 
        {
          $xfer += ${iter83}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_closeScanner_args;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_closeScanner_args->mk_accessors( qw( scannerId ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{scannerId} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{scannerId}) {
      $self->{scannerId} = $vals->{scannerId};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_closeScanner_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{scannerId});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_closeScanner_args');
  if (defined $self->{scannerId}) {
    $xfer += $output->writeFieldBegin('scannerId', TType::I32, 1);
    $xfer += $output->writeI32($self->{scannerId});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseService_closeScanner_result;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::THBaseService_closeScanner_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'THBaseService_closeScanner_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Thrift::API::HBaseClient2::TIOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ia} = new Thrift::API::HBaseClient2::TIllegalArgument();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('THBaseService_closeScanner_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::THBaseServiceIf;

use strict;


sub exists{
  my $self = shift;
  my $table = shift;
  my $get = shift;

  die 'implement interface';
}

sub get{
  my $self = shift;
  my $table = shift;
  my $get = shift;

  die 'implement interface';
}

sub getMultiple{
  my $self = shift;
  my $table = shift;
  my $gets = shift;

  die 'implement interface';
}

sub put{
  my $self = shift;
  my $table = shift;
  my $put = shift;

  die 'implement interface';
}

sub checkAndPut{
  my $self = shift;
  my $table = shift;
  my $row = shift;
  my $family = shift;
  my $qualifier = shift;
  my $value = shift;
  my $put = shift;

  die 'implement interface';
}

sub putMultiple{
  my $self = shift;
  my $table = shift;
  my $puts = shift;

  die 'implement interface';
}

sub deleteSingle{
  my $self = shift;
  my $table = shift;
  my $deleteSingle = shift;

  die 'implement interface';
}

sub deleteMultiple{
  my $self = shift;
  my $table = shift;
  my $deletes = shift;

  die 'implement interface';
}

sub checkAndDelete{
  my $self = shift;
  my $table = shift;
  my $row = shift;
  my $family = shift;
  my $qualifier = shift;
  my $value = shift;
  my $deleteSingle = shift;

  die 'implement interface';
}

sub increment{
  my $self = shift;
  my $table = shift;
  my $increment = shift;

  die 'implement interface';
}

sub openScanner{
  my $self = shift;
  my $table = shift;
  my $scan = shift;

  die 'implement interface';
}

sub getScannerRows{
  my $self = shift;
  my $scannerId = shift;
  my $numRows = shift;

  die 'implement interface';
}

sub closeScanner{
  my $self = shift;
  my $scannerId = shift;

  die 'implement interface';
}

package Thrift::API::HBaseClient2::THBaseServiceRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub exists{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $get = ($request->{'get'}) ? $request->{'get'} : undef;
  return $self->{impl}->exists($table, $get);
}

sub get{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $get = ($request->{'get'}) ? $request->{'get'} : undef;
  return $self->{impl}->get($table, $get);
}

sub getMultiple{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $gets = ($request->{'gets'}) ? $request->{'gets'} : undef;
  return $self->{impl}->getMultiple($table, $gets);
}

sub put{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $put = ($request->{'put'}) ? $request->{'put'} : undef;
  return $self->{impl}->put($table, $put);
}

sub checkAndPut{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $family = ($request->{'family'}) ? $request->{'family'} : undef;
  my $qualifier = ($request->{'qualifier'}) ? $request->{'qualifier'} : undef;
  my $value = ($request->{'value'}) ? $request->{'value'} : undef;
  my $put = ($request->{'put'}) ? $request->{'put'} : undef;
  return $self->{impl}->checkAndPut($table, $row, $family, $qualifier, $value, $put);
}

sub putMultiple{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $puts = ($request->{'puts'}) ? $request->{'puts'} : undef;
  return $self->{impl}->putMultiple($table, $puts);
}

sub deleteSingle{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $deleteSingle = ($request->{'deleteSingle'}) ? $request->{'deleteSingle'} : undef;
  return $self->{impl}->deleteSingle($table, $deleteSingle);
}

sub deleteMultiple{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $deletes = ($request->{'deletes'}) ? $request->{'deletes'} : undef;
  return $self->{impl}->deleteMultiple($table, $deletes);
}

sub checkAndDelete{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $family = ($request->{'family'}) ? $request->{'family'} : undef;
  my $qualifier = ($request->{'qualifier'}) ? $request->{'qualifier'} : undef;
  my $value = ($request->{'value'}) ? $request->{'value'} : undef;
  my $deleteSingle = ($request->{'deleteSingle'}) ? $request->{'deleteSingle'} : undef;
  return $self->{impl}->checkAndDelete($table, $row, $family, $qualifier, $value, $deleteSingle);
}

sub increment{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $increment = ($request->{'increment'}) ? $request->{'increment'} : undef;
  return $self->{impl}->increment($table, $increment);
}

sub openScanner{
  my ($self, $request) = @_;

  my $table = ($request->{'table'}) ? $request->{'table'} : undef;
  my $scan = ($request->{'scan'}) ? $request->{'scan'} : undef;
  return $self->{impl}->openScanner($table, $scan);
}

sub getScannerRows{
  my ($self, $request) = @_;

  my $scannerId = ($request->{'scannerId'}) ? $request->{'scannerId'} : undef;
  my $numRows = ($request->{'numRows'}) ? $request->{'numRows'} : undef;
  return $self->{impl}->getScannerRows($scannerId, $numRows);
}

sub closeScanner{
  my ($self, $request) = @_;

  my $scannerId = ($request->{'scannerId'}) ? $request->{'scannerId'} : undef;
  return $self->{impl}->closeScanner($scannerId);
}

package Thrift::API::HBaseClient2::THBaseServiceClient;


use base qw(Thrift::API::HBaseClient2::THBaseServiceIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub exists{
  my $self = shift;
  my $table = shift;
  my $get = shift;

    $self->send_exists($table, $get);
  return $self->recv_exists();
}

sub send_exists{
  my $self = shift;
  my $table = shift;
  my $get = shift;

  $self->{output}->writeMessageBegin('exists', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HBaseClient2::THBaseService_exists_args();
  $args->{table} = $table;
  $args->{get} = $get;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_exists{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HBaseClient2::THBaseService_exists_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "exists failed: unknown result";
}
sub get{
  my $self = shift;
  my $table = shift;
  my $get = shift;

    $self->send_get($table, $get);
  return $self->recv_get();
}

sub send_get{
  my $self = shift;
  my $table = shift;
  my $get = shift;

  $self->{output}->writeMessageBegin('get', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HBaseClient2::THBaseService_get_args();
  $args->{table} = $table;
  $args->{get} = $get;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HBaseClient2::THBaseService_get_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "get failed: unknown result";
}
sub getMultiple{
  my $self = shift;
  my $table = shift;
  my $gets = shift;

    $self->send_getMultiple($table, $gets);
  return $self->recv_getMultiple();
}

sub send_getMultiple{
  my $self = shift;
  my $table = shift;
  my $gets = shift;

  $self->{output}->writeMessageBegin('getMultiple', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HBaseClient2::THBaseService_getMultiple_args();
  $args->{table} = $table;
  $args->{gets} = $gets;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getMultiple{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HBaseClient2::THBaseService_getMultiple_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getMultiple failed: unknown result";
}
sub put{
  my $self = shift;
  my $table = shift;
  my $put = shift;

    $self->send_put($table, $put);
  $self->recv_put();
}

sub send_put{
  my $self = shift;
  my $table = shift;
  my $put = shift;

  $self->{output}->writeMessageBegin('put', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HBaseClient2::THBaseService_put_args();
  $args->{table} = $table;
  $args->{put} = $put;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_put{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HBaseClient2::THBaseService_put_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub checkAndPut{
  my $self = shift;
  my $table = shift;
  my $row = shift;
  my $family = shift;
  my $qualifier = shift;
  my $value = shift;
  my $put = shift;

    $self->send_checkAndPut($table, $row, $family, $qualifier, $value, $put);
  return $self->recv_checkAndPut();
}

sub send_checkAndPut{
  my $self = shift;
  my $table = shift;
  my $row = shift;
  my $family = shift;
  my $qualifier = shift;
  my $value = shift;
  my $put = shift;

  $self->{output}->writeMessageBegin('checkAndPut', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HBaseClient2::THBaseService_checkAndPut_args();
  $args->{table} = $table;
  $args->{row} = $row;
  $args->{family} = $family;
  $args->{qualifier} = $qualifier;
  $args->{value} = $value;
  $args->{put} = $put;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_checkAndPut{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HBaseClient2::THBaseService_checkAndPut_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "checkAndPut failed: unknown result";
}
sub putMultiple{
  my $self = shift;
  my $table = shift;
  my $puts = shift;

    $self->send_putMultiple($table, $puts);
  $self->recv_putMultiple();
}

sub send_putMultiple{
  my $self = shift;
  my $table = shift;
  my $puts = shift;

  $self->{output}->writeMessageBegin('putMultiple', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HBaseClient2::THBaseService_putMultiple_args();
  $args->{table} = $table;
  $args->{puts} = $puts;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_putMultiple{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HBaseClient2::THBaseService_putMultiple_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub deleteSingle{
  my $self = shift;
  my $table = shift;
  my $deleteSingle = shift;

    $self->send_deleteSingle($table, $deleteSingle);
  $self->recv_deleteSingle();
}

sub send_deleteSingle{
  my $self = shift;
  my $table = shift;
  my $deleteSingle = shift;

  $self->{output}->writeMessageBegin('deleteSingle', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HBaseClient2::THBaseService_deleteSingle_args();
  $args->{table} = $table;
  $args->{deleteSingle} = $deleteSingle;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_deleteSingle{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HBaseClient2::THBaseService_deleteSingle_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub deleteMultiple{
  my $self = shift;
  my $table = shift;
  my $deletes = shift;

    $self->send_deleteMultiple($table, $deletes);
  return $self->recv_deleteMultiple();
}

sub send_deleteMultiple{
  my $self = shift;
  my $table = shift;
  my $deletes = shift;

  $self->{output}->writeMessageBegin('deleteMultiple', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HBaseClient2::THBaseService_deleteMultiple_args();
  $args->{table} = $table;
  $args->{deletes} = $deletes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_deleteMultiple{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HBaseClient2::THBaseService_deleteMultiple_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "deleteMultiple failed: unknown result";
}
sub checkAndDelete{
  my $self = shift;
  my $table = shift;
  my $row = shift;
  my $family = shift;
  my $qualifier = shift;
  my $value = shift;
  my $deleteSingle = shift;

    $self->send_checkAndDelete($table, $row, $family, $qualifier, $value, $deleteSingle);
  return $self->recv_checkAndDelete();
}

sub send_checkAndDelete{
  my $self = shift;
  my $table = shift;
  my $row = shift;
  my $family = shift;
  my $qualifier = shift;
  my $value = shift;
  my $deleteSingle = shift;

  $self->{output}->writeMessageBegin('checkAndDelete', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HBaseClient2::THBaseService_checkAndDelete_args();
  $args->{table} = $table;
  $args->{row} = $row;
  $args->{family} = $family;
  $args->{qualifier} = $qualifier;
  $args->{value} = $value;
  $args->{deleteSingle} = $deleteSingle;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_checkAndDelete{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HBaseClient2::THBaseService_checkAndDelete_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "checkAndDelete failed: unknown result";
}
sub increment{
  my $self = shift;
  my $table = shift;
  my $increment = shift;

    $self->send_increment($table, $increment);
  return $self->recv_increment();
}

sub send_increment{
  my $self = shift;
  my $table = shift;
  my $increment = shift;

  $self->{output}->writeMessageBegin('increment', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HBaseClient2::THBaseService_increment_args();
  $args->{table} = $table;
  $args->{increment} = $increment;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_increment{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HBaseClient2::THBaseService_increment_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "increment failed: unknown result";
}
sub openScanner{
  my $self = shift;
  my $table = shift;
  my $scan = shift;

    $self->send_openScanner($table, $scan);
  return $self->recv_openScanner();
}

sub send_openScanner{
  my $self = shift;
  my $table = shift;
  my $scan = shift;

  $self->{output}->writeMessageBegin('openScanner', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HBaseClient2::THBaseService_openScanner_args();
  $args->{table} = $table;
  $args->{scan} = $scan;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_openScanner{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HBaseClient2::THBaseService_openScanner_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "openScanner failed: unknown result";
}
sub getScannerRows{
  my $self = shift;
  my $scannerId = shift;
  my $numRows = shift;

    $self->send_getScannerRows($scannerId, $numRows);
  return $self->recv_getScannerRows();
}

sub send_getScannerRows{
  my $self = shift;
  my $scannerId = shift;
  my $numRows = shift;

  $self->{output}->writeMessageBegin('getScannerRows', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HBaseClient2::THBaseService_getScannerRows_args();
  $args->{scannerId} = $scannerId;
  $args->{numRows} = $numRows;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getScannerRows{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HBaseClient2::THBaseService_getScannerRows_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  die "getScannerRows failed: unknown result";
}
sub closeScanner{
  my $self = shift;
  my $scannerId = shift;

    $self->send_closeScanner($scannerId);
  $self->recv_closeScanner();
}

sub send_closeScanner{
  my $self = shift;
  my $scannerId = shift;

  $self->{output}->writeMessageBegin('closeScanner', TMessageType::CALL, $self->{seqid});
  my $args = new Thrift::API::HBaseClient2::THBaseService_closeScanner_args();
  $args->{scannerId} = $scannerId;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_closeScanner{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Thrift::API::HBaseClient2::THBaseService_closeScanner_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  return;
}
package Thrift::API::HBaseClient2::THBaseServiceProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_exists {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HBaseClient2::THBaseService_exists_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HBaseClient2::THBaseService_exists_result();
    eval {
      $result->{success} = $self->{handler}->exists($args->table, $args->get);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HBaseClient2::TIOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('exists', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HBaseClient2::THBaseService_get_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HBaseClient2::THBaseService_get_result();
    eval {
      $result->{success} = $self->{handler}->get($args->table, $args->get);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HBaseClient2::TIOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('get', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getMultiple {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HBaseClient2::THBaseService_getMultiple_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HBaseClient2::THBaseService_getMultiple_result();
    eval {
      $result->{success} = $self->{handler}->getMultiple($args->table, $args->gets);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HBaseClient2::TIOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getMultiple', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_put {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HBaseClient2::THBaseService_put_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HBaseClient2::THBaseService_put_result();
    eval {
      $self->{handler}->put($args->table, $args->put);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HBaseClient2::TIOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('put', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_checkAndPut {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HBaseClient2::THBaseService_checkAndPut_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HBaseClient2::THBaseService_checkAndPut_result();
    eval {
      $result->{success} = $self->{handler}->checkAndPut($args->table, $args->row, $args->family, $args->qualifier, $args->value, $args->put);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HBaseClient2::TIOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('checkAndPut', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_putMultiple {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HBaseClient2::THBaseService_putMultiple_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HBaseClient2::THBaseService_putMultiple_result();
    eval {
      $self->{handler}->putMultiple($args->table, $args->puts);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HBaseClient2::TIOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('putMultiple', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_deleteSingle {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HBaseClient2::THBaseService_deleteSingle_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HBaseClient2::THBaseService_deleteSingle_result();
    eval {
      $self->{handler}->deleteSingle($args->table, $args->deleteSingle);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HBaseClient2::TIOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('deleteSingle', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_deleteMultiple {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HBaseClient2::THBaseService_deleteMultiple_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HBaseClient2::THBaseService_deleteMultiple_result();
    eval {
      $result->{success} = $self->{handler}->deleteMultiple($args->table, $args->deletes);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HBaseClient2::TIOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('deleteMultiple', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_checkAndDelete {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HBaseClient2::THBaseService_checkAndDelete_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HBaseClient2::THBaseService_checkAndDelete_result();
    eval {
      $result->{success} = $self->{handler}->checkAndDelete($args->table, $args->row, $args->family, $args->qualifier, $args->value, $args->deleteSingle);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HBaseClient2::TIOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('checkAndDelete', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_increment {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HBaseClient2::THBaseService_increment_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HBaseClient2::THBaseService_increment_result();
    eval {
      $result->{success} = $self->{handler}->increment($args->table, $args->increment);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HBaseClient2::TIOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('increment', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_openScanner {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HBaseClient2::THBaseService_openScanner_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HBaseClient2::THBaseService_openScanner_result();
    eval {
      $result->{success} = $self->{handler}->openScanner($args->table, $args->scan);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HBaseClient2::TIOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('openScanner', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getScannerRows {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HBaseClient2::THBaseService_getScannerRows_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HBaseClient2::THBaseService_getScannerRows_result();
    eval {
      $result->{success} = $self->{handler}->getScannerRows($args->scannerId, $args->numRows);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HBaseClient2::TIOError') ){ 
      $result->{io} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HBaseClient2::TIllegalArgument') ){ 
      $result->{ia} = $@;
    }
    $output->writeMessageBegin('getScannerRows', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_closeScanner {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Thrift::API::HBaseClient2::THBaseService_closeScanner_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Thrift::API::HBaseClient2::THBaseService_closeScanner_result();
    eval {
      $self->{handler}->closeScanner($args->scannerId);
    }; if( UNIVERSAL::isa($@,'Thrift::API::HBaseClient2::TIOError') ){ 
      $result->{io} = $@;
        }; if( UNIVERSAL::isa($@,'Thrift::API::HBaseClient2::TIllegalArgument') ){ 
      $result->{ia} = $@;
    }
    $output->writeMessageBegin('closeScanner', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
