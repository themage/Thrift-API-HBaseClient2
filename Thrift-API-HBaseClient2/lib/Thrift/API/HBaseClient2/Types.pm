#
# Autogenerated by Thrift Compiler (0.9.1)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

package Thrift::API::HBaseClient2::TDeleteType;
use constant DELETE_COLUMN => 0;
use constant DELETE_COLUMNS => 1;
package Thrift::API::HBaseClient2::TTimeRange;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::TTimeRange->mk_accessors( qw( minStamp maxStamp ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{minStamp} = undef;
  $self->{maxStamp} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{minStamp}) {
      $self->{minStamp} = $vals->{minStamp};
    }
    if (defined $vals->{maxStamp}) {
      $self->{maxStamp} = $vals->{maxStamp};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TTimeRange';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{minStamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{maxStamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TTimeRange');
  if (defined $self->{minStamp}) {
    $xfer += $output->writeFieldBegin('minStamp', TType::I64, 1);
    $xfer += $output->writeI64($self->{minStamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{maxStamp}) {
    $xfer += $output->writeFieldBegin('maxStamp', TType::I64, 2);
    $xfer += $output->writeI64($self->{maxStamp});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::TColumn;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::TColumn->mk_accessors( qw( family qualifier timestamp ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{family} = undef;
  $self->{qualifier} = undef;
  $self->{timestamp} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{family}) {
      $self->{family} = $vals->{family};
    }
    if (defined $vals->{qualifier}) {
      $self->{qualifier} = $vals->{qualifier};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TColumn';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{qualifier});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TColumn');
  if (defined $self->{family}) {
    $xfer += $output->writeFieldBegin('family', TType::STRING, 1);
    $xfer += $output->writeString($self->{family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{qualifier}) {
    $xfer += $output->writeFieldBegin('qualifier', TType::STRING, 2);
    $xfer += $output->writeString($self->{qualifier});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::TColumnValue;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::TColumnValue->mk_accessors( qw( family qualifier value timestamp ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{family} = undef;
  $self->{qualifier} = undef;
  $self->{value} = undef;
  $self->{timestamp} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{family}) {
      $self->{family} = $vals->{family};
    }
    if (defined $vals->{qualifier}) {
      $self->{qualifier} = $vals->{qualifier};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TColumnValue';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{qualifier});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TColumnValue');
  if (defined $self->{family}) {
    $xfer += $output->writeFieldBegin('family', TType::STRING, 1);
    $xfer += $output->writeString($self->{family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{qualifier}) {
    $xfer += $output->writeFieldBegin('qualifier', TType::STRING, 2);
    $xfer += $output->writeString($self->{qualifier});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::STRING, 3);
    $xfer += $output->writeString($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::TColumnIncrement;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::TColumnIncrement->mk_accessors( qw( family qualifier amount ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{family} = undef;
  $self->{qualifier} = undef;
  $self->{amount} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{family}) {
      $self->{family} = $vals->{family};
    }
    if (defined $vals->{qualifier}) {
      $self->{qualifier} = $vals->{qualifier};
    }
    if (defined $vals->{amount}) {
      $self->{amount} = $vals->{amount};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TColumnIncrement';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{qualifier});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{amount});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TColumnIncrement');
  if (defined $self->{family}) {
    $xfer += $output->writeFieldBegin('family', TType::STRING, 1);
    $xfer += $output->writeString($self->{family});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{qualifier}) {
    $xfer += $output->writeFieldBegin('qualifier', TType::STRING, 2);
    $xfer += $output->writeString($self->{qualifier});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{amount}) {
    $xfer += $output->writeFieldBegin('amount', TType::I64, 3);
    $xfer += $output->writeI64($self->{amount});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::TResult;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::TResult->mk_accessors( qw( row columnValues ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{row} = undef;
  $self->{columnValues} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{columnValues}) {
      $self->{columnValues} = $vals->{columnValues};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TResult';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size0 = 0;
          $self->{columnValues} = [];
          my $_etype3 = 0;
          $xfer += $input->readListBegin(\$_etype3, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $elem5 = undef;
            $elem5 = new Thrift::API::HBaseClient2::TColumnValue();
            $xfer += $elem5->read($input);
            push(@{$self->{columnValues}},$elem5);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TResult');
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 1);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnValues}) {
    $xfer += $output->writeFieldBegin('columnValues', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columnValues}}));
      {
        foreach my $iter6 (@{$self->{columnValues}}) 
        {
          $xfer += ${iter6}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::TGet;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::TGet->mk_accessors( qw( row columns timestamp timeRange maxVersions ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{row} = undef;
  $self->{columns} = undef;
  $self->{timestamp} = undef;
  $self->{timeRange} = undef;
  $self->{maxVersions} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{timeRange}) {
      $self->{timeRange} = $vals->{timeRange};
    }
    if (defined $vals->{maxVersions}) {
      $self->{maxVersions} = $vals->{maxVersions};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TGet';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size7 = 0;
          $self->{columns} = [];
          my $_etype10 = 0;
          $xfer += $input->readListBegin(\$_etype10, \$_size7);
          for (my $_i11 = 0; $_i11 < $_size7; ++$_i11)
          {
            my $elem12 = undef;
            $elem12 = new Thrift::API::HBaseClient2::TColumn();
            $xfer += $elem12->read($input);
            push(@{$self->{columns}},$elem12);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{timeRange} = new Thrift::API::HBaseClient2::TTimeRange();
        $xfer += $self->{timeRange}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{maxVersions});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TGet');
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 1);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter13 (@{$self->{columns}}) 
        {
          $xfer += ${iter13}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timeRange}) {
    $xfer += $output->writeFieldBegin('timeRange', TType::STRUCT, 4);
    $xfer += $self->{timeRange}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{maxVersions}) {
    $xfer += $output->writeFieldBegin('maxVersions', TType::I32, 5);
    $xfer += $output->writeI32($self->{maxVersions});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::TPut;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::TPut->mk_accessors( qw( row columnValues timestamp writeToWal ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{row} = undef;
  $self->{columnValues} = undef;
  $self->{timestamp} = undef;
  $self->{writeToWal} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{columnValues}) {
      $self->{columnValues} = $vals->{columnValues};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{writeToWal}) {
      $self->{writeToWal} = $vals->{writeToWal};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TPut';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size14 = 0;
          $self->{columnValues} = [];
          my $_etype17 = 0;
          $xfer += $input->readListBegin(\$_etype17, \$_size14);
          for (my $_i18 = 0; $_i18 < $_size14; ++$_i18)
          {
            my $elem19 = undef;
            $elem19 = new Thrift::API::HBaseClient2::TColumnValue();
            $xfer += $elem19->read($input);
            push(@{$self->{columnValues}},$elem19);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{writeToWal});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TPut');
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 1);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnValues}) {
    $xfer += $output->writeFieldBegin('columnValues', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columnValues}}));
      {
        foreach my $iter20 (@{$self->{columnValues}}) 
        {
          $xfer += ${iter20}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{writeToWal}) {
    $xfer += $output->writeFieldBegin('writeToWal', TType::BOOL, 4);
    $xfer += $output->writeBool($self->{writeToWal});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::TDelete;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::TDelete->mk_accessors( qw( row columns timestamp deleteType writeToWal ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{row} = undef;
  $self->{columns} = undef;
  $self->{timestamp} = undef;
  $self->{deleteType} = 1;
  $self->{writeToWal} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{deleteType}) {
      $self->{deleteType} = $vals->{deleteType};
    }
    if (defined $vals->{writeToWal}) {
      $self->{writeToWal} = $vals->{writeToWal};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TDelete';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size21 = 0;
          $self->{columns} = [];
          my $_etype24 = 0;
          $xfer += $input->readListBegin(\$_etype24, \$_size21);
          for (my $_i25 = 0; $_i25 < $_size21; ++$_i25)
          {
            my $elem26 = undef;
            $elem26 = new Thrift::API::HBaseClient2::TColumn();
            $xfer += $elem26->read($input);
            push(@{$self->{columns}},$elem26);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{deleteType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{writeToWal});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TDelete');
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 1);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter27 (@{$self->{columns}}) 
        {
          $xfer += ${iter27}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deleteType}) {
    $xfer += $output->writeFieldBegin('deleteType', TType::I32, 4);
    $xfer += $output->writeI32($self->{deleteType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{writeToWal}) {
    $xfer += $output->writeFieldBegin('writeToWal', TType::BOOL, 5);
    $xfer += $output->writeBool($self->{writeToWal});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::TIncrement;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::TIncrement->mk_accessors( qw( row columns writeToWal ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{row} = undef;
  $self->{columns} = undef;
  $self->{writeToWal} = 1;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{writeToWal}) {
      $self->{writeToWal} = $vals->{writeToWal};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TIncrement';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size28 = 0;
          $self->{columns} = [];
          my $_etype31 = 0;
          $xfer += $input->readListBegin(\$_etype31, \$_size28);
          for (my $_i32 = 0; $_i32 < $_size28; ++$_i32)
          {
            my $elem33 = undef;
            $elem33 = new Thrift::API::HBaseClient2::TColumnIncrement();
            $xfer += $elem33->read($input);
            push(@{$self->{columns}},$elem33);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{writeToWal});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TIncrement');
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 1);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter34 (@{$self->{columns}}) 
        {
          $xfer += ${iter34}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{writeToWal}) {
    $xfer += $output->writeFieldBegin('writeToWal', TType::BOOL, 3);
    $xfer += $output->writeBool($self->{writeToWal});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::TScan;
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::TScan->mk_accessors( qw( startRow stopRow columns caching maxVersions timeRange ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{startRow} = undef;
  $self->{stopRow} = undef;
  $self->{columns} = undef;
  $self->{caching} = undef;
  $self->{maxVersions} = 1;
  $self->{timeRange} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{startRow}) {
      $self->{startRow} = $vals->{startRow};
    }
    if (defined $vals->{stopRow}) {
      $self->{stopRow} = $vals->{stopRow};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{caching}) {
      $self->{caching} = $vals->{caching};
    }
    if (defined $vals->{maxVersions}) {
      $self->{maxVersions} = $vals->{maxVersions};
    }
    if (defined $vals->{timeRange}) {
      $self->{timeRange} = $vals->{timeRange};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TScan';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{startRow});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{stopRow});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size35 = 0;
          $self->{columns} = [];
          my $_etype38 = 0;
          $xfer += $input->readListBegin(\$_etype38, \$_size35);
          for (my $_i39 = 0; $_i39 < $_size35; ++$_i39)
          {
            my $elem40 = undef;
            $elem40 = new Thrift::API::HBaseClient2::TColumn();
            $xfer += $elem40->read($input);
            push(@{$self->{columns}},$elem40);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{caching});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{maxVersions});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{timeRange} = new Thrift::API::HBaseClient2::TTimeRange();
        $xfer += $self->{timeRange}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TScan');
  if (defined $self->{startRow}) {
    $xfer += $output->writeFieldBegin('startRow', TType::STRING, 1);
    $xfer += $output->writeString($self->{startRow});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stopRow}) {
    $xfer += $output->writeFieldBegin('stopRow', TType::STRING, 2);
    $xfer += $output->writeString($self->{stopRow});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columns}}));
      {
        foreach my $iter41 (@{$self->{columns}}) 
        {
          $xfer += ${iter41}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{caching}) {
    $xfer += $output->writeFieldBegin('caching', TType::I32, 4);
    $xfer += $output->writeI32($self->{caching});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{maxVersions}) {
    $xfer += $output->writeFieldBegin('maxVersions', TType::I32, 5);
    $xfer += $output->writeI32($self->{maxVersions});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timeRange}) {
    $xfer += $output->writeFieldBegin('timeRange', TType::STRUCT, 6);
    $xfer += $self->{timeRange}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::TIOError;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::TIOError->mk_accessors( qw( message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TIOError';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TIOError');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Thrift::API::HBaseClient2::TIllegalArgument;
use base qw(Thrift::TException);
use base qw(Class::Accessor);
Thrift::API::HBaseClient2::TIllegalArgument->mk_accessors( qw( message ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{message} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{message}) {
      $self->{message} = $vals->{message};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'TIllegalArgument';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{message});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('TIllegalArgument');
  if (defined $self->{message}) {
    $xfer += $output->writeFieldBegin('message', TType::STRING, 1);
    $xfer += $output->writeString($self->{message});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;
